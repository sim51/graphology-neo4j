{"version":3,"sources":["webpack://graphology-neo4j/webpack/universalModuleDefinition","webpack://graphology-neo4j/./src/cypher-to-graph.ts","webpack://graphology-neo4j/external \"graphology\"","webpack://graphology-neo4j/external \"neo4j-driver\"","webpack://graphology-neo4j/./src/cypher-projection-to-graph.ts","webpack://graphology-neo4j/webpack/bootstrap","webpack://graphology-neo4j/./src/index.ts"],"names":[],"mappings":"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","file":"graphology-neo4j.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"graphology\"), require(\"neo4j-driver\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"graphology\", \"neo4j-driver\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"graphology-neo4j\"] = factory(require(\"graphology\"), require(\"neo4j-driver\"));\n\telse\n\t\troot[\"graphology-neo4j\"] = factory(root[\"graphology\"], root[\"neo4j-driver\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__3__) {\nreturn ","import Graph from \"graphology\";\nimport { session, Driver, Neo4jError, Node, Path, PathSegment, Record, Relationship, Session } from \"neo4j-driver\";\nimport { Vertex, Edge, CypherToGraphOpts } from \"./types\";\n\n/**\n * Create a graphology graph based on the result of a cypher query.\n *\n * @param neo4j Object with the neo4j's driver and optionally the database name\n * @param cypher Query to executed for the graph creation\n * @param params Query's parameters\n * @param opts Allow you to defined the graphology attribut mapping for neo4j's ids (default @id), node's labels (default @labels) & relationship's type (default @type).\n * @returns A graphology instance\n */\nexport function cypherToGraph(\n  neo4j: { driver: Driver; database?: string },\n  cypher: string,\n  params: { [param: string]: unknown } = {},\n  opts: CypherToGraphOpts = { id: \"@id\", labels: \"@labels\", type: \"@type\" },\n): Promise<Graph> {\n  return new Promise<Graph>((resolve, reject) => {\n    const graph = new Graph({\n      multi: true,\n      type: \"directed\",\n      allowSelfLoops: true,\n    });\n\n    const neoSession: Session = neo4j.driver.session({\n      defaultAccessMode: session.READ,\n      database: neo4j.database,\n    });\n    neoSession.run(cypher, params).subscribe({\n      onNext: (record: Record) => {\n        // for each column\n        record.forEach((value: unknown) => {\n          try {\n            pushValueInGraph(value, graph, opts);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      },\n      onCompleted: () => {\n        neoSession.close();\n        resolve(graph);\n      },\n      onError: (error: Neo4jError) => {\n        neoSession.close();\n        reject(error);\n      },\n    });\n  });\n}\n\n/**\n * Given a query record item, do it's best to cast it as a graph elements (ie. node or relation),\n * and add add them in the graph.\n * NOTE: This method modifies the provided graph instance.\n *\n * @param value A record item to add\n * @param graph Graph instance on which we add the graph elements\n * @param opts Graphology attribut mapping for neo4j specific fields\n */\nfunction pushValueInGraph(value: unknown, graph: Graph, opts: CypherToGraphOpts): void {\n  // check if it's a node\n  if (isNode(value)) {\n    mergeNodeInGraph(value as Node, graph, opts);\n  }\n  // check if it's a Relationship\n  else if (isRelationship(value)) {\n    mergeRelationshipInGraph(value as Relationship, graph, opts);\n  }\n  // check if it's a Path\n  else if (isPath(value)) {\n    const path = value as Path;\n    mergeNodeInGraph(path.start, graph, opts);\n    path.segments.forEach((seg: PathSegment) => {\n      mergeNodeInGraph(seg.start, graph, opts);\n      mergeRelationshipInGraph(seg.relationship, graph, opts);\n      mergeNodeInGraph(seg.end, graph, opts);\n    });\n  } else if (Array.isArray(value)) {\n    value.forEach((item: unknown) => {\n      pushValueInGraph(item, graph, opts);\n    });\n  } else if (Object.prototype.toString.call(value) === \"[object Object]\") {\n    Object.keys(value).forEach(key => {\n      pushValueInGraph(value[key], graph, opts);\n    });\n  }\n}\n\n/**\n * Convert a Neo4j Node object and merge it into the graph instance.\n * NOTE: This method modifies the provided graph instance.\n *\n * @param node The Neo4j node to merge in the graph\n * @param graph The graph instance in which the node will be added.\n * @param opts Graphology attribut mapping for neo4j specific fields\n */\nfunction mergeNodeInGraph(node: Node, graph: Graph, opts: CypherToGraphOpts): void {\n  const vertex: Vertex = { ...node.properties, [opts.id]: node.identity.toString(), [opts.labels]: node.labels };\n  graph.mergeNode(node.identity.toString(), vertex);\n}\n\n/**\n * Convert a Neo4j Relatonship object and merge it into the graph instance.\n * NOTE: This method modifies the provided graph instance.\n *\n * @param rel The Neo4j relatiponship to merge in the graph\n * @param graph The graph instance in which the node will be added.\n * @param opts Graphology attribut mapping for neo4j specific fields\n */\nfunction mergeRelationshipInGraph(rel: Relationship, graph: Graph, opts: CypherToGraphOpts): void {\n  const edge: Edge = { ...rel.properties, [opts.id]: rel.identity.toString(), [opts.type]: rel.type };\n  graph.mergeEdgeWithKey(rel.identity.toString(), `${rel.start}`, `${rel.end}`, edge);\n}\n\n/**\n * Given an object returned by the neo4j driver, this method check if it's a Node or not.\n *\n * @param object The cypher object to check\n * @returns `true` if the object is a Node, `false` otherwise\n */\nfunction isNode(object: unknown): boolean {\n  let isNode = false;\n  if (\n    object &&\n    Object.prototype.hasOwnProperty.call(object, \"identity\") &&\n    Object.prototype.hasOwnProperty.call(object, \"labels\")\n  ) {\n    isNode = true;\n  }\n  return isNode;\n}\n\n/**\n * Given an object returned by the neo4j driver, this method check if it's a Relationship or not.\n *\n * @param object The cypher object to check\n * @returns `true` if the object is a Relationship, `false` otherwise\n */\nfunction isRelationship(object: unknown): boolean {\n  let isRel = false;\n  if (\n    object &&\n    Object.prototype.hasOwnProperty.call(object, \"identity\") &&\n    Object.prototype.hasOwnProperty.call(object, \"type\") &&\n    Object.prototype.hasOwnProperty.call(object, \"start\") &&\n    Object.prototype.hasOwnProperty.call(object, \"end\")\n  ) {\n    isRel = true;\n  }\n  return isRel;\n}\n\n/**\n * Given an object returned by the neo4j driver, this method check if it's a path or not.\n *\n * @param object The cypher object to check\n * @returns `true` if the object is a Path, `false` otherwise\n */\nfunction isPath(object: unknown): boolean {\n  let isPath = false;\n  if (\n    object &&\n    Object.prototype.hasOwnProperty.call(object, \"start\") &&\n    Object.prototype.hasOwnProperty.call(object, \"end\") &&\n    Object.prototype.hasOwnProperty.call(object, \"segments\")\n  ) {\n    isPath = true;\n  }\n  return isPath;\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","import Graph from \"graphology\";\nimport { session, Driver, Neo4jError, Record, Session } from \"neo4j-driver\";\nimport { Vertex, Edge, CypherToGraphOpts } from \"./types\";\n\n/**\n * Create a graphology graph based on the cypher projection queries.\n *\n * @param neo4j Object with the neo4j's driver and optionally the database name\n * @param cypherNodes The query to executed to get nodes. The query must return an `id` field and other fiels with be added as node's property\n * @param cypherRelationships The query to executed to get edges. The query must returns a field `source` and `target`,\n * @param params Query parameters that will be passed to both queries\n * @param opts Allow you to defined the graphology attribut mapping for neo4j's ids (default @id), node's labels (default @labels) & relationship's type (default @type).\n * @returns A graphology instance\n */\nexport async function cypherProjectionToGraph(\n  neo4j: { driver: Driver; database?: string },\n  cypherNodes: string,\n  cypherRelationships: string,\n  params: { [param: string]: unknown } = {},\n  opts: CypherToGraphOpts = { id: \"@id\", labels: \"@labels\", type: \"@type\" },\n): Promise<Graph> {\n  // Init the graph\n  const graph = new Graph({\n    multi: true,\n    type: \"directed\",\n    allowSelfLoops: true,\n  });\n\n  // Create the session\n  const neoSession: Session = neo4j.driver.session({\n    defaultAccessMode: session.READ,\n    database: neo4j.database,\n  });\n\n  // Load nodes\n  await new Promise<void>((resolveNodes, rejectNodes) => {\n    neoSession.run(cypherNodes, params).subscribe({\n      onNext: (record: Record) => {\n        if (!record.has(\"id\")) rejectNodes(new Error(\"Node's query must return an `id` field\"));\n        const { id, labels, ...props } = record.toObject();\n        const node: Vertex = { ...props, [opts.id]: id, [opts.labels]: labels || [] };\n        graph.mergeNode(id, node);\n      },\n      onCompleted: () => {\n        resolveNodes();\n      },\n      onError: (error: Neo4jError) => {\n        neoSession.close();\n        rejectNodes(error);\n      },\n    });\n  });\n\n  // Load relationship\n  await new Promise<void>((resolveEdges, rejectEdges) => {\n    neoSession.run(cypherRelationships, params).subscribe({\n      onNext: (record: Record) => {\n        if (!record.has(\"source\") || !record.has(\"target\"))\n          rejectEdges(new Error(\"Relationship's query must return an `source` & `target` field\"));\n        const { source, target, id, type, ...props } = record.toObject();\n        const relId = id || `${source}->${target}`;\n        const rel: Edge = { ...props, [opts.id]: relId, [opts.type]: type || \"\" };\n        graph.mergeEdgeWithKey(relId, source, target, rel);\n      },\n      onCompleted: () => {\n        neoSession.close();\n        resolveEdges();\n      },\n      onError: (error: Neo4jError) => {\n        neoSession.close();\n        rejectEdges(error);\n      },\n    });\n  });\n\n  // return the computed graph\n  return graph;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { Vertex, Edge } from \"./types\";\nimport { cypherToGraph } from \"./cypher-to-graph\";\nimport { cypherProjectionToGraph } from \"./cypher-projection-to-graph\";\n\nexport { cypherToGraph, cypherProjectionToGraph, Vertex, Edge };\n"],"sourceRoot":""}