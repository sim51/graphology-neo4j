{"version":3,"sources":["webpack://graphology-neo4j/webpack/universalModuleDefinition","webpack://graphology-neo4j/./src/cypher-to-graph.ts","webpack://graphology-neo4j/external \"graphology\"","webpack://graphology-neo4j/external \"neo4j-driver\"","webpack://graphology-neo4j/./src/cypher-projection-to-graph.ts","webpack://graphology-neo4j/webpack/bootstrap","webpack://graphology-neo4j/./src/index.ts"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__2__","__WEBPACK_EXTERNAL_MODULE__3__","pushValueInGraph","value","graph","opts","object","isNode","Object","prototype","hasOwnProperty","call","mergeNodeInGraph","isRel","isRelationship","mergeRelationshipInGraph","isPath","path","start","segments","forEach","seg","relationship","end","Array","isArray","item","toString","keys","key","node","vertex","properties","id","identity","labels","mergeNode","rel","edge","type","mergeEdgeWithKey","neo4j","cypher","params","Promise","resolve","reject","multi","allowSelfLoops","neoSession","driver","session","defaultAccessMode","READ","database","run","subscribe","onNext","record","e","onCompleted","close","onError","error","cypherNodes","cypherRelationships","resolveNodes","rejectNodes","has","Error","toObject","props","resolveEdges","rejectEdges","source","target","relId","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","cypherToGraph","cypherProjectionToGraph"],"mappings":"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","file":"graphology-neo4j.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"graphology\"), require(\"neo4j-driver\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"graphology\", \"neo4j-driver\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"graphology-neo4j\"] = factory(require(\"graphology\"), require(\"neo4j-driver\"));\n\telse\n\t\troot[\"graphology-neo4j\"] = factory(root[\"graphology\"], root[\"neo4j-driver\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__3__) {\nreturn ","import Graph from \"graphology\";\nimport { session, Driver, Neo4jError, Node, Path, PathSegment, Record, Relationship, Session } from \"neo4j-driver\";\nimport { Vertex, Edge, CypherToGraphOpts } from \"./types\";\n\n/**\n * Create a graphology graph based on the result of a cypher query.\n *\n * @param neo4j Object with the neo4j's driver and optionally the database name\n * @param cypher Query to executed for the graph creation\n * @param params Query's parameters\n * @param opts Allow you to defined the graphology attribut mapping for neo4j's ids (default @id), node's labels (default @labels) & relationship's type (default @type).\n * @returns A graphology instance\n */\nexport function cypherToGraph(\n  neo4j: { driver: Driver; database?: string },\n  cypher: string,\n  params: { [param: string]: unknown } = {},\n  opts: CypherToGraphOpts = { id: \"@id\", labels: \"@labels\", type: \"@type\" },\n): Promise<Graph> {\n  return new Promise<Graph>((resolve, reject) => {\n    const graph = new Graph({\n      multi: true,\n      type: \"directed\",\n      allowSelfLoops: true,\n    });\n\n    const neoSession: Session = neo4j.driver.session({\n      defaultAccessMode: session.READ,\n      database: neo4j.database,\n    });\n    neoSession.run(cypher, params).subscribe({\n      onNext: (record: Record) => {\n        // for each column\n        record.forEach((value: unknown) => {\n          try {\n            pushValueInGraph(value, graph, opts);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      },\n      onCompleted: () => {\n        neoSession.close();\n        resolve(graph);\n      },\n      onError: (error: Neo4jError) => {\n        neoSession.close();\n        reject(error);\n      },\n    });\n  });\n}\n\n/**\n * Given a query record item, do it's best to cast it as a graph elements (ie. node or relation),\n * and add add them in the graph.\n * NOTE: This method modifies the provided graph instance.\n *\n * @param value A record item to add\n * @param graph Graph instance on which we add the graph elements\n * @param opts Graphology attribut mapping for neo4j specific fields\n */\nfunction pushValueInGraph(value: unknown, graph: Graph, opts: CypherToGraphOpts): void {\n  // check if it's a node\n  if (isNode(value)) {\n    mergeNodeInGraph(value as Node, graph, opts);\n  }\n  // check if it's a Relationship\n  else if (isRelationship(value)) {\n    mergeRelationshipInGraph(value as Relationship, graph, opts);\n  }\n  // check if it's a Path\n  else if (isPath(value)) {\n    const path = value as Path;\n    mergeNodeInGraph(path.start, graph, opts);\n    path.segments.forEach((seg: PathSegment) => {\n      mergeNodeInGraph(seg.start, graph, opts);\n      mergeRelationshipInGraph(seg.relationship, graph, opts);\n      mergeNodeInGraph(seg.end, graph, opts);\n    });\n  } else if (Array.isArray(value)) {\n    value.forEach((item: unknown) => {\n      pushValueInGraph(item, graph, opts);\n    });\n  } else if (Object.prototype.toString.call(value) === \"[object Object]\") {\n    Object.keys(value).forEach(key => {\n      pushValueInGraph(value[key], graph, opts);\n    });\n  }\n}\n\n/**\n * Convert a Neo4j Node object and merge it into the graph instance.\n * NOTE: This method modifies the provided graph instance.\n *\n * @param node The Neo4j node to merge in the graph\n * @param graph The graph instance in which the node will be added.\n * @param opts Graphology attribut mapping for neo4j specific fields\n */\nfunction mergeNodeInGraph(node: Node, graph: Graph, opts: CypherToGraphOpts): void {\n  const vertex: Vertex = { ...node.properties, [opts.id]: node.identity.toString(), [opts.labels]: node.labels };\n  graph.mergeNode(node.identity.toString(), vertex);\n}\n\n/**\n * Convert a Neo4j Relatonship object and merge it into the graph instance.\n * NOTE: This method modifies the provided graph instance.\n *\n * @param rel The Neo4j relatiponship to merge in the graph\n * @param graph The graph instance in which the node will be added.\n * @param opts Graphology attribut mapping for neo4j specific fields\n */\nfunction mergeRelationshipInGraph(rel: Relationship, graph: Graph, opts: CypherToGraphOpts): void {\n  const edge: Edge = { ...rel.properties, [opts.id]: rel.identity.toString(), [opts.type]: rel.type };\n  graph.mergeEdgeWithKey(rel.identity.toString(), `${rel.start}`, `${rel.end}`, edge);\n}\n\n/**\n * Given an object returned by the neo4j driver, this method check if it's a Node or not.\n *\n * @param object The cypher object to check\n * @returns `true` if the object is a Node, `false` otherwise\n */\nfunction isNode(object: unknown): boolean {\n  let isNode = false;\n  if (\n    object &&\n    Object.prototype.hasOwnProperty.call(object, \"identity\") &&\n    Object.prototype.hasOwnProperty.call(object, \"labels\")\n  ) {\n    isNode = true;\n  }\n  return isNode;\n}\n\n/**\n * Given an object returned by the neo4j driver, this method check if it's a Relationship or not.\n *\n * @param object The cypher object to check\n * @returns `true` if the object is a Relationship, `false` otherwise\n */\nfunction isRelationship(object: unknown): boolean {\n  let isRel = false;\n  if (\n    object &&\n    Object.prototype.hasOwnProperty.call(object, \"identity\") &&\n    Object.prototype.hasOwnProperty.call(object, \"type\") &&\n    Object.prototype.hasOwnProperty.call(object, \"start\") &&\n    Object.prototype.hasOwnProperty.call(object, \"end\")\n  ) {\n    isRel = true;\n  }\n  return isRel;\n}\n\n/**\n * Given an object returned by the neo4j driver, this method check if it's a path or not.\n *\n * @param object The cypher object to check\n * @returns `true` if the object is a Path, `false` otherwise\n */\nfunction isPath(object: unknown): boolean {\n  let isPath = false;\n  if (\n    object &&\n    Object.prototype.hasOwnProperty.call(object, \"start\") &&\n    Object.prototype.hasOwnProperty.call(object, \"end\") &&\n    Object.prototype.hasOwnProperty.call(object, \"segments\")\n  ) {\n    isPath = true;\n  }\n  return isPath;\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","import Graph from \"graphology\";\nimport { session, Driver, Neo4jError, Record, Session } from \"neo4j-driver\";\nimport { Vertex, Edge, CypherToGraphOpts } from \"./types\";\n\n/**\n * Create a graphology graph based on the cypher projection queries.\n *\n * @param neo4j Object with the neo4j's driver and optionally the database name\n * @param cypherNodes The query to executed to get nodes. The query must return an `id` field and other fiels with be added as node's property\n * @param cypherRelationships The query to executed to get edges. The query must returns a field `source` and `target`,\n * @param params Query parameters that will be passed to both queries\n * @param opts Allow you to defined the graphology attribut mapping for neo4j's ids (default @id), node's labels (default @labels) & relationship's type (default @type).\n * @returns A graphology instance\n */\nexport async function cypherProjectionToGraph(\n  neo4j: { driver: Driver; database?: string },\n  cypherNodes: string,\n  cypherRelationships: string,\n  params: { [param: string]: unknown } = {},\n  opts: CypherToGraphOpts = { id: \"@id\", labels: \"@labels\", type: \"@type\" },\n): Promise<Graph> {\n  // Init the graph\n  const graph = new Graph({\n    multi: true,\n    type: \"directed\",\n    allowSelfLoops: true,\n  });\n\n  // Create the session\n  const neoSession: Session = neo4j.driver.session({\n    defaultAccessMode: session.READ,\n    database: neo4j.database,\n  });\n\n  // Load nodes\n  await new Promise<void>((resolveNodes, rejectNodes) => {\n    neoSession.run(cypherNodes, params).subscribe({\n      onNext: (record: Record) => {\n        if (!record.has(\"id\")) rejectNodes(new Error(\"Node's query must return an `id` field\"));\n        const { id, labels, ...props } = record.toObject();\n        const node: Vertex = { ...props, [opts.id]: id, [opts.labels]: labels || [] };\n        graph.mergeNode(id, node);\n      },\n      onCompleted: () => {\n        resolveNodes();\n      },\n      onError: (error: Neo4jError) => {\n        neoSession.close();\n        rejectNodes(error);\n      },\n    });\n  });\n\n  // Load relationship\n  await new Promise<void>((resolveEdges, rejectEdges) => {\n    neoSession.run(cypherRelationships, params).subscribe({\n      onNext: (record: Record) => {\n        if (!record.has(\"source\") || !record.has(\"target\"))\n          rejectEdges(new Error(\"Relationship's query must return an `source` & `target` field\"));\n        const { source, target, id, type, ...props } = record.toObject();\n        const relId = id || `${source}->${target}`;\n        const rel: Edge = { ...props, [opts.id]: relId, [opts.type]: type || \"\" };\n        graph.mergeEdgeWithKey(relId, source, target, rel);\n      },\n      onCompleted: () => {\n        neoSession.close();\n        resolveEdges();\n      },\n      onError: (error: Neo4jError) => {\n        neoSession.close();\n        rejectEdges(error);\n      },\n    });\n  });\n\n  // return the computed graph\n  return graph;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { Vertex, Edge } from \"./types\";\nimport { cypherToGraph } from \"./cypher-to-graph\";\nimport { cypherProjectionToGraph } from \"./cypher-projection-to-graph\";\n\nexport { cypherToGraph, cypherProjectionToGraph, Vertex, Edge };\n"],"sourceRoot":""}